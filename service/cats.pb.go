// Code generated by protoc-gen-gogo.
// source: cats.proto
// DO NOT EDIT!

package service

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/opsee/protobuf/opseeproto"
import _ "github.com/opsee/protobuf/opseeproto/types"
import opsee1 "github.com/opsee/basic/schema"
import opsee2 "github.com/opsee/basic/schema"

import github_com_graphql_go_graphql "github.com/graphql-go/graphql"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ListChecksRequest struct {
	User *opsee1.User `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
}

func (m *ListChecksRequest) Reset()         { *m = ListChecksRequest{} }
func (m *ListChecksRequest) String() string { return proto.CompactTextString(m) }
func (*ListChecksRequest) ProtoMessage()    {}

func (m *ListChecksRequest) GetUser() *opsee1.User {
	if m != nil {
		return m.User
	}
	return nil
}

type ListChecksResponse struct {
	Checks []*opsee2.Check `protobuf:"bytes,1,rep,name=checks" json:"checks,omitempty"`
}

func (m *ListChecksResponse) Reset()         { *m = ListChecksResponse{} }
func (m *ListChecksResponse) String() string { return proto.CompactTextString(m) }
func (*ListChecksResponse) ProtoMessage()    {}

func (m *ListChecksResponse) GetChecks() []*opsee2.Check {
	if m != nil {
		return m.Checks
	}
	return nil
}

func init() {
	proto.RegisterType((*ListChecksRequest)(nil), "opsee.ListChecksRequest")
	proto.RegisterType((*ListChecksResponse)(nil), "opsee.ListChecksResponse")
}
func (this *ListChecksRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListChecksRequest)
	if !ok {
		that2, ok := that.(ListChecksRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	return true
}
func (this *ListChecksResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListChecksResponse)
	if !ok {
		that2, ok := that.(ListChecksResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Checks) != len(that1.Checks) {
		return false
	}
	for i := range this.Checks {
		if !this.Checks[i].Equal(that1.Checks[i]) {
			return false
		}
	}
	return true
}

type ListChecksRequestGetter interface {
	GetListChecksRequest() *ListChecksRequest
}

var GraphQLListChecksRequestType *github_com_graphql_go_graphql.Object

type ListChecksResponseGetter interface {
	GetListChecksResponse() *ListChecksResponse
}

var GraphQLListChecksResponseType *github_com_graphql_go_graphql.Object

func init() {
	GraphQLListChecksRequestType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "serviceListChecksRequest",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"user": &github_com_graphql_go_graphql.Field{
					Type:        opsee1.GraphQLUserType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListChecksRequest)
						if ok {
							if obj.User == nil {
								return nil, nil
							}
							return obj.GetUser(), nil
						}
						inter, ok := p.Source.(ListChecksRequestGetter)
						if ok {
							face := inter.GetListChecksRequest()
							if face == nil {
								return nil, nil
							}
							if face.User == nil {
								return nil, nil
							}
							return face.GetUser(), nil
						}
						return nil, fmt.Errorf("field user not resolved")
					},
				},
			}
		}),
	})
	GraphQLListChecksResponseType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "serviceListChecksResponse",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"checks": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(opsee2.GraphQLCheckType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListChecksResponse)
						if ok {
							return obj.Checks, nil
						}
						inter, ok := p.Source.(ListChecksResponseGetter)
						if ok {
							face := inter.GetListChecksResponse()
							if face == nil {
								return nil, nil
							}
							return face.Checks, nil
						}
						return nil, fmt.Errorf("field checks not resolved")
					},
				},
			}
		}),
	})
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Cats service

type CatsClient interface {
	ListChecks(ctx context.Context, in *ListChecksRequest, opts ...grpc.CallOption) (*ListChecksResponse, error)
}

type catsClient struct {
	cc *grpc.ClientConn
}

func NewCatsClient(cc *grpc.ClientConn) CatsClient {
	return &catsClient{cc}
}

func (c *catsClient) ListChecks(ctx context.Context, in *ListChecksRequest, opts ...grpc.CallOption) (*ListChecksResponse, error) {
	out := new(ListChecksResponse)
	err := grpc.Invoke(ctx, "/opsee.Cats/ListChecks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Cats service

type CatsServer interface {
	ListChecks(context.Context, *ListChecksRequest) (*ListChecksResponse, error)
}

func RegisterCatsServer(s *grpc.Server, srv CatsServer) {
	s.RegisterService(&_Cats_serviceDesc, srv)
}

func _Cats_ListChecks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CatsServer).ListChecks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Cats_serviceDesc = grpc.ServiceDesc{
	ServiceName: "opsee.Cats",
	HandlerType: (*CatsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListChecks",
			Handler:    _Cats_ListChecks_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func NewPopulatedListChecksRequest(r randyCats, easy bool) *ListChecksRequest {
	this := &ListChecksRequest{}
	if r.Intn(10) != 0 {
		this.User = opsee1.NewPopulatedUser(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedListChecksResponse(r randyCats, easy bool) *ListChecksResponse {
	this := &ListChecksResponse{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Checks = make([]*opsee2.Check, v1)
		for i := 0; i < v1; i++ {
			this.Checks[i] = opsee2.NewPopulatedCheck(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyCats interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneCats(r randyCats) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringCats(r randyCats) string {
	v2 := r.Intn(100)
	tmps := make([]rune, v2)
	for i := 0; i < v2; i++ {
		tmps[i] = randUTF8RuneCats(r)
	}
	return string(tmps)
}
func randUnrecognizedCats(r randyCats, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldCats(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldCats(data []byte, r randyCats, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateCats(data, uint64(key))
		v3 := r.Int63()
		if r.Intn(2) == 0 {
			v3 *= -1
		}
		data = encodeVarintPopulateCats(data, uint64(v3))
	case 1:
		data = encodeVarintPopulateCats(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateCats(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateCats(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateCats(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateCats(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
